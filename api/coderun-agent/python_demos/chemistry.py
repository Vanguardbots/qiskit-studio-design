# Copyright contributors to the Qiskit Studio project
# SPDX-License-Identifier: Apache-2.0

## STEP 0 : IBM Quantum Config
from qiskit_ibm_runtime import QiskitRuntimeService

service = QiskitRuntimeService()
backend = service.least_busy(operational=True, simulator=False)
print(f"Using IBM backend: {backend.name}")

## STEP 1 : Mapping the problem

###[Chemistry]
import pyscf
import pyscf.cc
import pyscf.mcscf

# Specify molecule properties
open_shell = False
spin_sq = 0

#### INPUT PYTHON
# H₂ - testbed molecule
# Basis set options: Adaptive minimal (~2 qubits), STO-3G (~2 qubits)
mol = pyscf.gto.Mole()
mol.build(
    atom=[["H", (0.0, 0.0, 0.0)], ["H", (0.74, 0.0, 0.0)]],  # bond length ~0.74 Å
    basis="cc-pvdz",
    symmetry="Dooh",  # Same symmetry as N₂ - linear molecule with inversion
    spin=0,
    charge=0,
)
#### END INPUT PYTHON

# Define active space - FIXED: Use fewer frozen orbitals
n_frozen = 0  # Changed from 2 to 0 - don't freeze orbitals for H2
active_space = range(n_frozen, mol.nao_nr())

# Get molecular integrals
scf = pyscf.scf.RHF(mol).run()
num_orbitals = len(active_space)
n_electrons = int(sum(scf.mo_occ[active_space]))
num_elec_a = (n_electrons + mol.spin) // 2
num_elec_b = (n_electrons - mol.spin) // 2

print(f"Number of orbitals: {num_orbitals}")
print(f"Number of electrons: {n_electrons}")
print(f"Qubits needed: {2 * num_orbitals}")

cas = pyscf.mcscf.CASCI(scf, num_orbitals, (num_elec_a, num_elec_b))
mo = cas.sort_mo(active_space, base=0)
hcore, nuclear_repulsion_energy = cas.get_h1cas(mo)
eri = pyscf.ao2mo.restore(1, cas.get_h2cas(mo), num_orbitals)

# Compute exact energy
exact_energy = cas.run().e_tot

# Get CCSD t2 amplitudes for initializing the ansatz
ccsd = pyscf.cc.CCSD(
    scf, frozen=[i for i in range(mol.nao_nr()) if i not in active_space]
).run()
t1 = ccsd.t1
t2 = ccsd.t2

###[UVJ Circuit]
import ffsim
from qiskit import QuantumCircuit, QuantumRegister

n_reps = 1
alpha_alpha_indices = [(p, p + 1) for p in range(num_orbitals - 1)]
alpha_beta_indices = [(p, p) for p in range(0, num_orbitals, 4)]

ucj_op = ffsim.UCJOpSpinBalanced.from_t_amplitudes(
    t2=t2,
    t1=t1,
    n_reps=n_reps,
    interaction_pairs=(alpha_alpha_indices, alpha_beta_indices),
)

nelec = (num_elec_a, num_elec_b)

# create an empty quantum circuit
qubits = QuantumRegister(2 * num_orbitals, name="q")
circuit = QuantumCircuit(qubits)

# prepare Hartree-Fock state as the reference state and append it to the quantum circuit
circuit.append(ffsim.qiskit.PrepareHartreeFockJW(num_orbitals, nelec), qubits)

# apply the UCJ operator to the reference state
circuit.append(ffsim.qiskit.UCJOpSpinBalancedJW(ucj_op), qubits)
circuit.measure_all()

## STEP 2 : Optimize Circuit
###[Transpiler]
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager

# FIXED: Create layout that matches actual circuit size
total_qubits = 2 * num_orbitals
print(f"Creating layout for {total_qubits} qubits")

# Use simple sequential layout instead of hardcoded one
initial_layout = list(range(total_qubits))

pass_manager = generate_preset_pass_manager(
    optimization_level=3, backend=backend, initial_layout=initial_layout
)

# without PRE_INIT passes
isa_circuit = pass_manager.run(circuit)
print(f"Gate counts (w/o pre-init passes): {isa_circuit.count_ops()}")

# with PRE_INIT passes
# We will use the circuit generated by this pass manager for hardware execution
try:
    pass_manager.pre_init = ffsim.qiskit.PRE_INIT
    isa_circuit = pass_manager.run(circuit)
    print(f"Gate counts (w/ pre-init passes): {isa_circuit.count_ops()}")
except Exception as e:
    print(f"PRE_INIT failed: {e}, using circuit without PRE_INIT")

## STEP 3 : Execute
###[Sampler]
# FIXED: Handle both IBM and local execution
if hasattr(backend, "name") and "aer" not in backend.name.lower():
    # IBM hardware execution
    from qiskit_ibm_runtime import SamplerV2 as Sampler

    sampler = Sampler(mode=backend)
    job = sampler.run([isa_circuit], shots=100_000)

    # Set resilience level to 1 for advanced error mitigation
    sampler.options.resilience_level = 1

    ###[Hardware Execution]
    primitive_result = job.result()
    pub_result = primitive_result[0]
    counts = pub_result.data.meas.get_counts()
else:
    # Local simulator execution
    job = backend.run(isa_circuit, shots=100_000)
    result = job.result()
    counts = result.get_counts()

print(f"Got {len(counts)} different measurement outcomes")

## STEP 4 : Post-process
###[SQD Analysis]
from qiskit_addon_sqd.counts import counts_to_arrays

# Convert counts into bitstring and probability arrays
bitstring_matrix_full, probs_arr_full = counts_to_arrays(counts)

import numpy as np
from qiskit_addon_sqd.configuration_recovery import recover_configurations
from qiskit_addon_sqd.fermion import solve_fermion
from qiskit_addon_sqd.subsampling import postselect_and_subsample

rng = np.random.default_rng(12345)

# SQD options
iterations = 5

# Eigenstate solver options
n_batches = 3
samples_per_batch = 1000
# max_davidson_cycles = 200

# Self-consistent configuration recovery loop
e_hist = np.zeros((iterations, n_batches))  # energy history
s_hist = np.zeros((iterations, n_batches))  # spin history
occupancy_hist = []
avg_occupancy = None
for i in range(iterations):
    print(f"Starting configuration recovery iteration {i}")
    # On the first iteration, we have no orbital occupancy information from the
    # solver, so we just post-select from the full bitstring set based on hamming weight.
    if avg_occupancy is None:
        bs_mat_tmp = bitstring_matrix_full
        probs_arr_tmp = probs_arr_full

    # If we have average orbital occupancy information, we use it to refine the full set of noisy configurations
    else:
        bs_mat_tmp, probs_arr_tmp = recover_configurations(
            bitstring_matrix_full,
            probs_arr_full,
            avg_occupancy,
            num_elec_a,
            num_elec_b,
            rand_seed=rng,
        )

    # Throw out configurations with incorrect particle number in either the spin-up or spin-down systems
    batches = postselect_and_subsample(
        bs_mat_tmp,
        probs_arr_tmp,
        hamming_right=num_elec_a,
        hamming_left=num_elec_b,
        samples_per_batch=samples_per_batch,
        num_batches=n_batches,
        rand_seed=rng,
    )

    # Run eigenstate solvers in a loop. This loop should be parallelized for larger problems.
    e_tmp = np.zeros(n_batches)
    s_tmp = np.zeros(n_batches)
    occs_tmp = []
    coeffs = []
    for j in range(n_batches):
        energy_sci, coeffs_sci, avg_occs, spin = solve_fermion(
            batches[j],
            hcore,
            eri,
            open_shell=open_shell,
            spin_sq=spin_sq,
            # max_davidson=max_davidson_cycles,
        )
        energy_sci += nuclear_repulsion_energy
        e_tmp[j] = energy_sci
        s_tmp[j] = spin
        occs_tmp.append(avg_occs)
        coeffs.append(coeffs_sci)

    # Combine batch results
    avg_occupancy = np.mean(occs_tmp, axis=0)

    # Track optimization history
    e_hist[i, :] = e_tmp
    s_hist[i, :] = s_tmp
    occupancy_hist.append(avg_occupancy)

    # Print iteration results
    mean_energy = np.mean(e_tmp)
    print(f"Iteration {i}: Mean energy = {mean_energy:.6f} Hartree\n")

# Print final results
output_text = f"Exact energy: {exact_energy:.6f} Hartree \n"
output_text += f"Final SQD energy: {np.mean(e_hist[-1]):.6f} Hartree \n"
output_text += f"Error: {abs(np.mean(e_hist[-1]) - exact_energy):.6f} Hartree\n"

print(f'RESULT: {{"type":"text","content":"{output_text}"}}')
